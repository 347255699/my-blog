<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>K8S 课程笔记——Operator基础 | Menfre Blog</title>
    <meta name="description" content="

学习 Operator 之前需要先深刻理解下声明式 API，声明式 API 是 kubernetes 编排赖以生存的关键特性。

&gt; 编排指的是维护容器以及容器之间的依赖关系。

我们在编排容器的时候，除了声明式 API 外。还有其他两种常见的操作方式。了解这两种方式可以让我们通过对比的方法来了解声明式 API。

命令式命令行
命令式配置文件

命令式命令行

命令式命令行的 ...">
    <meta name="generator" content="VuePress 1.4.0">
    <script src="https://www.googletagmanager.com/gtag/js?id=UA-164957843-1" async="true"></script>
  <script>window.dataLayer = window.dataLayer || [];            function gtag(){dataLayer.push(arguments);}            gtag('js', new Date());            gtag('config', 'UA-164957843-1');</script>
    
    <link rel="preload" href="/assets/css/0.styles.0a94a68e.css" as="style"><link rel="preload" href="/assets/js/app.8d42fabb.js" as="script"><link rel="preload" href="/assets/js/6.aea618f8.js" as="script"><link rel="preload" href="/assets/js/4.20006588.js" as="script"><link rel="preload" href="/assets/js/35.388ea9a8.js" as="script"><link rel="preload" href="/assets/js/7.403b6e6e.js" as="script"><link rel="prefetch" href="/assets/js/1.5cbf5643.js"><link rel="prefetch" href="/assets/js/10.3ae75870.js"><link rel="prefetch" href="/assets/js/11.a447f3c3.js"><link rel="prefetch" href="/assets/js/12.0449ba3d.js"><link rel="prefetch" href="/assets/js/13.75011fc7.js"><link rel="prefetch" href="/assets/js/14.572779d4.js"><link rel="prefetch" href="/assets/js/15.d8496b36.js"><link rel="prefetch" href="/assets/js/16.3c7370c7.js"><link rel="prefetch" href="/assets/js/17.f10c6f39.js"><link rel="prefetch" href="/assets/js/18.1abb8aa8.js"><link rel="prefetch" href="/assets/js/19.5ca12b0a.js"><link rel="prefetch" href="/assets/js/20.e1896da5.js"><link rel="prefetch" href="/assets/js/21.b5e744b7.js"><link rel="prefetch" href="/assets/js/22.01ca19aa.js"><link rel="prefetch" href="/assets/js/23.2aa5172f.js"><link rel="prefetch" href="/assets/js/24.92afe763.js"><link rel="prefetch" href="/assets/js/25.fad419e7.js"><link rel="prefetch" href="/assets/js/26.24545015.js"><link rel="prefetch" href="/assets/js/27.510e6dd2.js"><link rel="prefetch" href="/assets/js/28.12988af6.js"><link rel="prefetch" href="/assets/js/29.44772bc6.js"><link rel="prefetch" href="/assets/js/30.a1349a06.js"><link rel="prefetch" href="/assets/js/31.0d024f90.js"><link rel="prefetch" href="/assets/js/32.e66d53ec.js"><link rel="prefetch" href="/assets/js/33.96fc1f36.js"><link rel="prefetch" href="/assets/js/34.fd98863d.js"><link rel="prefetch" href="/assets/js/36.1d19334a.js"><link rel="prefetch" href="/assets/js/5.ef32696c.js"><link rel="prefetch" href="/assets/js/8.c5b9daff.js"><link rel="prefetch" href="/assets/js/9.42728225.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.dd605d22.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0a94a68e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">Menfre Blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">Menfre Blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        K8S 课程笔记——Operator基础
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">Menfre</span> <span itemprop="address">   in Shenzhen</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2021-03-12T00:00:00.000Z">
      2021-03-12
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-d832e844><a href="/tag/k8s" data-v-d832e844> k8s </a></li><li class="post-tag" data-v-d832e844><a href="/tag/docker" data-v-d832e844> docker </a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="声明式-api"><a href="#声明式-api" class="header-anchor">#</a> 声明式 API</h2> <p>学习 Operator 之前需要先深刻理解下声明式 API，声明式 API 是 kubernetes 编排赖以生存的关键特性。</p> <blockquote><p>编排指的是维护容器以及容器之间的依赖关系。</p></blockquote> <p>我们在编排容器的时候，除了声明式 API 外。还有其他两种常见的操作方式。了解这两种方式可以让我们通过对比的方法来了解声明式 API。</p> <ul><li>命令式命令行</li> <li>命令式配置文件</li></ul> <h3 id="命令式命令行"><a href="#命令式命令行" class="header-anchor">#</a> 命令式命令行</h3> <p>命令式命令行的方式是比较常见的方式，比如 docker 中的 run 命令，直接通过命令设置容器的运行参数来运行容器。</p> <div class="language-shell extra-class"><pre class="language-shell"><code> docker run --name some-mysql -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>my-secret-pw -d mysql:tag
</code></pre></div><h3 id="命令式配置文件"><a href="#命令式配置文件" class="header-anchor">#</a> 命令式配置文件</h3> <p>docker-compose 使用的就是命令式配置文件的方式，往往我们需要将容器的信息以及容器的依赖关系编写进一个 yaml 格式的配置文件，然后通过 docker-compose 的 up 命令将配置文件交给 docker-compose。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>docker-compose -f standalone-mysql-5.7.yaml up
</code></pre></div><p>同样的方式还有 kubectl 的 replace 命令。这种操作方式的特点是每一次运行都会创建出一个全新的 API 对象出来。</p> <h3 id="声明式-api-2"><a href="#声明式-api-2" class="header-anchor">#</a> 声明式 API</h3> <p>在 kubernetes 中通常我们使用 kubectl apply 命令就是使用了声明式 API 的方式在管理容器。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>kubectl apply -f mysql-statefulset.yaml
</code></pre></div><p>声明式 API 可以有多个 API 写入端通过 patch 的方式修改同一个 API 对象，多个 API 写入端修改同一个 API 对象往往会伴随着 merge 操作(声明中有相同的字段内容)。</p> <p>在 kubernetes 中用户往往只需要声明对象的基本信息以及预期状态，通过 apply 提交给 kubernetes 后，kubernetes 会有与之相关的一个或多个Initailizer、控制器等。通过 patch 的方式来修改同一份 API 对象。以此来联合达到用户所声明的预期状态。而用户在之后的时间里有修改 API 对象的需求也是通过 apply 即 patch 的方式来修改 API 对象这使得控制器原先对 API 对象的修改得以保留，用户新的修改不会产生新的 API 对象。</p> <p>这种持续修改并且作用在同一个 API 对象上的特性正是声明式 API 对象的好处。</p> <blockquote><p>kubernetes 能达到声明式 API 效果的命令还有 kubectl set image 以及 kubectl edit 等。</p></blockquote> <h2 id="api-对象"><a href="#api-对象" class="header-anchor">#</a> API 对象</h2> <p>kubernetes 中提供了许许多多的 API 资源对象，这些 API 资源对象有的用来描述应用，有的用来描述资源，而有的则用来描述编排方式。</p> <p>常见的 API 对象有：</p> <ul><li>Pod</li> <li>ConfigMap</li> <li>Deployment</li> <li>StatefulSet</li> <li>Service</li> <li>CronJob</li></ul> <p>kubernetes 中 API 对象可以通过一定的规则来定位。主要通过 Group、Version、Resouce 三部分来定位。</p> <p>比如声明一个 CronJob 对象：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v2alpha1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJob
<span class="token punctuation">...</span>
</code></pre></div><p>其中 batch 就是 Group，v2alpha1 就是 Version，而 CronJob 就是 Resouce，kubernetes 中就是通过 version 来进行 API 对象的多版本管理的。</p> <p>但需要注意的是像 Pod、Deployment 等 kubernetes 中标准的 API 对象它们的 Group 为 “ ”，所以这些对象的定义往往是这样的：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
</code></pre></div><p>它们会从 Version 开始匹配。</p> <p>从 v1.7 之后 kubernetes 允许我们通过 CRD(Custom Resource Definition)来定义我们自己的 API 资源对象。</p> <p>比如我们定义一种 Network API 资源；</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apiextensions.k8s.io/v1beta1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> CustomResourceDefinition
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> networks.samplecrd.k8s.io
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">group</span><span class="token punctuation">:</span> samplecrd.k8s.io
  <span class="token key atrule">version</span><span class="token punctuation">:</span> v1
  <span class="token key atrule">names</span><span class="token punctuation">:</span>
    <span class="token key atrule">kind</span><span class="token punctuation">:</span> Network
    <span class="token key atrule">plural</span><span class="token punctuation">:</span> networks
  <span class="token key atrule">scope</span><span class="token punctuation">:</span> Namespaced
</code></pre></div><p>将这个 CRD 通过 kubectl apply 交给 kubernetes 之后，我门就能创建自己的 CR 了。</p> <p>比如：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> samplecrd.k8s.io/v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Network
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> example<span class="token punctuation">-</span>network
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">cidr</span><span class="token punctuation">:</span> <span class="token string">&quot;192.168.0.0/16&quot;</span>
  <span class="token key atrule">gateway</span><span class="token punctuation">:</span> <span class="token string">&quot;192.168.0.1&quot;</span>
</code></pre></div><p>其中 samplecrd.k8s.io 就是我们自定义资源的组，v1 是我们的版本，而 Network 就是我们的资源名称。</p> <blockquote><p>需要注意的是资源组的名称必须有两个 <code>.</code>，比如 samplecrd.k8s.io 。</p></blockquote> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>声明式 API是 kubernetes 编排赖以生存的特性，深刻理解它有助于我们编写 operator。kubernetes 提供了许许多多的 API 对象资源来满足日常的编排需求。而面对相对复杂的编排需求，可以使用 CRD 来定义 API 对象资源，但光有 API 对象资源是不够的，我们还需要编写对应的控制器。而 CRD 加上自定义控制器就可以编写出自定义 operator 了。</p> <div class="gitalk-container"><div id="gitalk-container"></div></div></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#声明式-api" title="声明式 API">声明式 API</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#命令式命令行" title="命令式命令行">命令式命令行</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#命令式配置文件" title="命令式配置文件">命令式配置文件</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#声明式-api-2" title="声明式 API">声明式 API</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#api-对象" title="API 对象">API 对象</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#总结" title="总结">总结</a></div></div></div></div> <footer class="footer" data-v-fdbf4940><div class="footer-left-wrap" data-v-fdbf4940><ul class="contact" data-v-fdbf4940><li class="contact-item" data-v-fdbf4940><a href="https://github.com/347255699" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-fdbf4940><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-fdbf4940></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-fdbf4940><ul class="copyright" data-v-fdbf4940><li class="copyright-item" data-v-fdbf4940><a href="/2021/03/12/k8s-course-operator-pre/.html" class="nav-link" data-v-fdbf4940>Copyright © 2020 Menfre Blog.</a></li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8d42fabb.js" defer></script><script src="/assets/js/6.aea618f8.js" defer></script><script src="/assets/js/4.20006588.js" defer></script><script src="/assets/js/35.388ea9a8.js" defer></script><script src="/assets/js/7.403b6e6e.js" defer></script>
  </body>
</html>
