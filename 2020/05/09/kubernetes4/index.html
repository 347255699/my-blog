<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>认真学习 kubernetes——Pod | Menfre Blog</title>
    <meta name="description" content="

这里的 Pod 是 kubernetes 的原子调度单位，好比 docker 的调度单位是容器，操作系统的调度单位是进程一样。

大家知道 kubernetes 是一套容器基础设施，即容器的操作系统。为啥 kubernetes 不以容器作为调度单位而是另辟蹊径以 Pod 作为调度单位呢？

要回答这个问题，我们首先需要知道容器的本质是一个特殊的进程，它特殊就特殊在它是一个通过 Linux Na ...">
    <meta name="generator" content="VuePress 1.4.0">
    <script src="https://www.googletagmanager.com/gtag/js?id=UA-164957843-1" async="true"></script>
  <script>window.dataLayer = window.dataLayer || [];            function gtag(){dataLayer.push(arguments);}            gtag('js', new Date());            gtag('config', 'UA-164957843-1');</script>
    
    <link rel="preload" href="/assets/css/0.styles.0a94a68e.css" as="style"><link rel="preload" href="/assets/js/app.8d42fabb.js" as="script"><link rel="preload" href="/assets/js/6.aea618f8.js" as="script"><link rel="preload" href="/assets/js/4.20006588.js" as="script"><link rel="preload" href="/assets/js/23.2aa5172f.js" as="script"><link rel="preload" href="/assets/js/7.403b6e6e.js" as="script"><link rel="prefetch" href="/assets/js/1.5cbf5643.js"><link rel="prefetch" href="/assets/js/10.3ae75870.js"><link rel="prefetch" href="/assets/js/11.a447f3c3.js"><link rel="prefetch" href="/assets/js/12.0449ba3d.js"><link rel="prefetch" href="/assets/js/13.75011fc7.js"><link rel="prefetch" href="/assets/js/14.572779d4.js"><link rel="prefetch" href="/assets/js/15.d8496b36.js"><link rel="prefetch" href="/assets/js/16.3c7370c7.js"><link rel="prefetch" href="/assets/js/17.f10c6f39.js"><link rel="prefetch" href="/assets/js/18.1abb8aa8.js"><link rel="prefetch" href="/assets/js/19.5ca12b0a.js"><link rel="prefetch" href="/assets/js/20.e1896da5.js"><link rel="prefetch" href="/assets/js/21.b5e744b7.js"><link rel="prefetch" href="/assets/js/22.01ca19aa.js"><link rel="prefetch" href="/assets/js/24.92afe763.js"><link rel="prefetch" href="/assets/js/25.fad419e7.js"><link rel="prefetch" href="/assets/js/26.24545015.js"><link rel="prefetch" href="/assets/js/27.510e6dd2.js"><link rel="prefetch" href="/assets/js/28.12988af6.js"><link rel="prefetch" href="/assets/js/29.44772bc6.js"><link rel="prefetch" href="/assets/js/30.a1349a06.js"><link rel="prefetch" href="/assets/js/31.0d024f90.js"><link rel="prefetch" href="/assets/js/32.e66d53ec.js"><link rel="prefetch" href="/assets/js/33.96fc1f36.js"><link rel="prefetch" href="/assets/js/34.fd98863d.js"><link rel="prefetch" href="/assets/js/35.388ea9a8.js"><link rel="prefetch" href="/assets/js/36.1d19334a.js"><link rel="prefetch" href="/assets/js/5.ef32696c.js"><link rel="prefetch" href="/assets/js/8.c5b9daff.js"><link rel="prefetch" href="/assets/js/9.42728225.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.dd605d22.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0a94a68e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">Menfre Blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">Menfre Blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        认真学习 kubernetes——Pod
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">Menfre</span> <span itemprop="address">   in Shenzhen</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-05-09T00:00:00.000Z">
      2020-05-09
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-d832e844><a href="/tag/k8s" data-v-d832e844> k8s </a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="_1-pod-是什么，为什么我们需要它"><a href="#_1-pod-是什么，为什么我们需要它" class="header-anchor">#</a> 1. Pod 是什么，为什么我们需要它</h2> <p>这里的 Pod 是 kubernetes 的原子调度单位，好比 docker 的调度单位是容器，操作系统的调度单位是进程一样。</p> <p>大家知道 kubernetes 是一套容器基础设施，即容器的操作系统。为啥 kubernetes 不以容器作为调度单位而是另辟蹊径以 Pod 作为调度单位呢？</p> <p>要回答这个问题，我们首先需要知道容器的本质是一个特殊的进程，它特殊就特殊在它是一个通过 Linux Namespace 和 Cgroup 隔离和限制的进程。那我们知道操作系统的调度单位就是进程，而在实际情况下，进程在操作系统中并不会单打独斗，而是以进程组的方式被组织起来，相互协作共同完成某一责职。</p> <p>而在 kubernetes 中就是将进程组这个概念映射成 Pod。</p> <h2 id="_2-成组调度"><a href="#_2-成组调度" class="header-anchor">#</a> 2. 成组调度</h2> <p>实际上 Pod 就是一个成组调度的概念。往往我们在集群环境上部署容器时，都需要借助一个 Paas 平台将我们的容器部署到合适的节点上。好比 Docker Swarm，假设我们有容器 a、b、c，a b c 之间是一个紧密协作的关系，它们需要被部署到同一个节点上才能正常工作，这里我们在后面两个容器中通过 affinity=a 来声明它们是紧密关系。同时运行容器 a b c 分别需要消耗 1G 内存。此时我们集群上有节点 node-A、node-B，node-A 内存为 3G，node-B 内存为 2.5G。Ok，现在我们用如下命令执行：</p> <div class="language-shell extra-class"><pre class="language-shell"><code>docker run a
docker run b <span class="token assign-left variable">affinity</span><span class="token operator">=</span>a
dokcer run c <span class="token assign-left variable">affinity</span><span class="token operator">=</span>a
</code></pre></div><p>执行完毕后容器 a b c 都会进入 Swarm 的调度队列，假如 a b 容器出队列都被调度到 node-B 上运行，此时因为 affinity 声明的关系，容器 c 必须在 node-B 上被调度，这时 Swarm 就会懵逼了，因为 Node-B 的内存不足以调度容器 c 了。</p> <p>这就是一个成组调度没有被妥善处理的典型例子。</p> <p>当然针对成组调度还有很多可行但不完美的方案，比如 Mesos 的资源囤积，等 Affinity 约束的容器都到达后再统一调度。又如 Google Omega 中的乐观锁，先不关心是否产生冲突逐一调度，等冲突发生时再通过精心设计的回滚机制回滚。</p> <p>当然这些措施都不算完美，资源囤积有效率损失和死锁风险，回滚机制的技术要求又比较高。</p> <p>铺垫了那么久，我们重新回到 Pod 来。kubernetes 以 Pod 为调度单位，只会选择满足 Pod 资源的节点来调度，就不存在成组调度问题,</p> <h2 id="_3-容器设计模式"><a href="#_3-容器设计模式" class="header-anchor">#</a> 3. 容器设计模式</h2> <p>当然在 kubernetes 中以 Pod 为调度单位可不仅仅是因为成组调度那么简单。更重要的是容器设计模式。</p> <h3 id="pod-原理"><a href="#pod-原理" class="header-anchor">#</a> Pod 原理</h3> <p>要了解容器设计模式，我们需要先了解下 Pod 的实现原理。</p> <p>这里 Pod 只是一个逻辑概念，在 kubernetes 中并不存在 Pod 的隔离边界，实际还是以 Linux 上的 Namespace 和 Cgroups 作为隔离环境。</p> <p>而在 Pod 里，所有的容器共享同一个 Network Namespace，并可以声明共享同一个 Volume。</p> <p>当然 docker 也可以通过 --net 和 --volumes-from 来实现。</p> <div class="language-shell extra-class"><pre class="language-shell"><code>docker run --net<span class="token operator">=</span>B --volumes-from<span class="token operator">=</span>B --name<span class="token operator">=</span>A image-A
</code></pre></div><p>但 docker 的问题是先要运行容器才能让另一个容器加入相同的 Network Namespace 或是共享一个 Volume。因此它们并不是对等结构。</p> <p>而 Pod 显然要高明得多，Pod 实现了一个 infra 容器，每一个 Pod 在创建的时候都会先创建一个 infra 容器。infra 容器的用途就是先初始化一个 Network Namespace 或其他 Namespace，能够让用户自定义应用容器通过 join infra Namespace 方式关联在一起。这样的组织关系如图：</p> <p><img src="/image/pod.png" alt="pod"></p> <p>Infra 在 Pod 是一个占位容器，因此需要占用极少的资源，所以它是一个用汇编语言编写的，永远处于暂停状态的镜像，叫做 k8s.gcr.io/pause。解压后的大小只有 100 ～ 200 KB。</p> <p>这里需要注意的是，容器 A B 的进出流量都是通过 Infra 来代理的。因此任何对 Pod 的网络配置或 Volume 挂载其实是对 Infra 容器生效，又因为用户自定义的容器与 Infra 容器共享同一 Namespace，因此对 Infra 配置也是对用户容器可见的。</p> <p>有了这个设计后我们在容器间共享 Volume 就容易多了。一个对应宿主机目录的 Volume 对于 Pod 就只有一个。只要 Pod 里的容器声明挂载这个 Volume 就可以实现共享了。</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
	<span class="token key atrule">name</span><span class="token punctuation">:</span> two<span class="token punctuation">-</span>containers
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> Never
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> shared<span class="token punctuation">-</span>data
    <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>      
      <span class="token key atrule">path</span><span class="token punctuation">:</span> /data
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>container
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> shared<span class="token punctuation">-</span>data
      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /usr/share/nginx/html
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> debian<span class="token punctuation">-</span>container
    <span class="token key atrule">image</span><span class="token punctuation">:</span> debian
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> shared<span class="token punctuation">-</span>data
      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /pod<span class="token punctuation">-</span>data
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;/bin/sh&quot;</span><span class="token punctuation">]</span>
    <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;-c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;echo Hello from the debian container &gt; /pod-data/index.html&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>这里我们声明了两个容器 nginx-container 和 debian-container，它们都声明挂载了 shared-data volume。而 shared-data 是 hostPath 类型。所以它在宿主机上的目录就是 /data。而这个目录就被同时挂载进了两个容器里了。</p> <p>这样 nginx-container 就能从 /usr/share/nginx/html 读取到 debian-container 生成的 index.html 了。</p> <h3 id="sidecar-模式"><a href="#sidecar-模式" class="header-anchor">#</a> Sidecar 模式</h3> <p>Pod 这种超亲密关系的容器设计思想，实际上是希望用户在遇到一个容器跑多个功能的时候，可以考虑将它们描述成一个 Pod 里的多个容器。</p> <p>这里举例 Tomcat 容器和 WAR 包。</p> <p>这里我们要通过容器来实现将一个 WAR 包放到 Tomcat 的 webapps 目录下并运行起来。</p> <ul><li>一种方法是将 WAR 包和 Tomcat 打包进一个容器中。但是考虑 WAR 包一旦更换就需要打包一个新的镜像。</li> <li>另一个方法是在容器中挂载一个对应宿主机目录的 volume，但这个又需要在每台服务器上初始化对应的目录和准备好 WAR 包。</li></ul> <p>而在 Pod 中我们可以考虑将 Tomcat 打包成一个镜像，将 WAR 包打包成一个镜像。然后通过共享 volume 的方式运行起来。</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
  <span class="token key atrule">name</span><span class="token punctuation">:</span> javaweb<span class="token punctuation">-</span><span class="token number">2</span>
<span class="token key atrule">spec</span><span class="token punctuation">:</span>
  <span class="token key atrule">initContainers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> geektime/sample<span class="token punctuation">:</span>v2
    <span class="token key atrule">name</span><span class="token punctuation">:</span> war
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;cp&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/sample.war&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/app&quot;</span><span class="token punctuation">]</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /app
      <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>volume
  <span class="token key atrule">containers</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> geektime/tomcat<span class="token punctuation">:</span><span class="token number">7.0</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> tomcat
    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;sh&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;-c&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;/root/apache-tomcat-7.0.42-v2/bin/start.sh&quot;</span><span class="token punctuation">]</span>
    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /root/apache<span class="token punctuation">-</span>tomcat<span class="token punctuation">-</span>7.0.42<span class="token punctuation">-</span>v2/webapps
      <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>volume
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">8080</span>
      <span class="token key atrule">hostPort</span><span class="token punctuation">:</span> <span class="token number">8001</span> 
  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>volume
    <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>这里我们声明了两个容器，第一个容器使用的镜像是 geektime/sample:v2 ，这个镜像只有一个存放在根目录的 WAR 包 sample.war。而另一个容器使用的镜像是 Tomcat。</p> <p>这里需要注意的是 WAR 包容器声明的是一个 initContainer 类型。initContainer 和 container 的区别在于，initContainer 会先于 container 且按照声明顺序运行，等 initContainer 运行完成才会运行普通的 container。</p> <p>这里我们 Pod 上挂载的 volume 是一个空目录 app-volume，即它只用于容器间共享。WAR 包容器将 app-volume 挂载到自己的 /app 目录。Tomcat 容器将 app-volume 挂载到自己的 /root/apache-tomcat-7.0.42-v2/webapps 目录下。当 WAR 包容器运行时就会将 sample.war 拷贝到对应目录上，因此 Tomcat 在运行时就能加载对应 Java 应用了。并且在之后需要更新 WAR 包时，只要打一个新的 WAR 包镜像即可。</p> <p>这种通过主从容器的组织方式我们称为 Sidecar 模式。即我们可以启动一个辅助容器独立于主容器完成一些工作。</p> <p>Istio 就是一个通过共享 Network Namespace 典型的 Sidecar 项目。</p> <p>最后为了更好的设计 Pod，我们需要了解下容器的单进程模型，容器的单进程模型不是说容器不允许创建多个进程，而是说容器没有管理多个进程的能力，因为每个容器内 PID=1 的进程就是容器本身，如果通过 docker container -it [containerId] /bin/bash 进入容器内创建的其他进程，这些进程在出现错误或做日志收集等，容器是管理不到的。这是容器的天性。</p> <div class="gitalk-container"><div id="gitalk-container"></div></div> <div class="gitalk-container"><div id="gitalk-container"></div></div></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#_1-pod-是什么，为什么我们需要它" title="1. Pod 是什么，为什么我们需要它">1. Pod 是什么，为什么我们需要它</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_2-成组调度" title="2. 成组调度">2. 成组调度</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_3-容器设计模式" title="3. 容器设计模式">3. 容器设计模式</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#pod-原理" title="Pod 原理">Pod 原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#sidecar-模式" title="Sidecar 模式">Sidecar 模式</a></div></div></div></div> <footer class="footer" data-v-fdbf4940><div class="footer-left-wrap" data-v-fdbf4940><ul class="contact" data-v-fdbf4940><li class="contact-item" data-v-fdbf4940><a href="https://github.com/347255699" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-fdbf4940><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-fdbf4940><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-fdbf4940></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-fdbf4940><ul class="copyright" data-v-fdbf4940><li class="copyright-item" data-v-fdbf4940><a href="/2020/05/09/kubernetes4/.html" class="nav-link" data-v-fdbf4940>Copyright © 2020 Menfre Blog.</a></li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8d42fabb.js" defer></script><script src="/assets/js/6.aea618f8.js" defer></script><script src="/assets/js/4.20006588.js" defer></script><script src="/assets/js/23.2aa5172f.js" defer></script><script src="/assets/js/7.403b6e6e.js" defer></script>
  </body>
</html>
