(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{375:function(a,t,s){"use strict";s.r(t);var e=s(9),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"声明式-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#声明式-api"}},[a._v("#")]),a._v(" 声明式 API")]),a._v(" "),s("p",[a._v("学习 Operator 之前需要先深刻理解下声明式 API，声明式 API 是 kubernetes 编排赖以生存的关键特性。")]),a._v(" "),s("blockquote",[s("p",[a._v("编排指的是维护容器以及容器之间的依赖关系。")])]),a._v(" "),s("p",[a._v("我们在编排容器的时候，除了声明式 API 外。还有其他两种常见的操作方式。了解这两种方式可以让我们通过对比的方法来了解声明式 API。")]),a._v(" "),s("ul",[s("li",[a._v("命令式命令行")]),a._v(" "),s("li",[a._v("命令式配置文件")])]),a._v(" "),s("h3",{attrs:{id:"命令式命令行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命令式命令行"}},[a._v("#")]),a._v(" 命令式命令行")]),a._v(" "),s("p",[a._v("命令式命令行的方式是比较常见的方式，比如 docker 中的 run 命令，直接通过命令设置容器的运行参数来运行容器。")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v(" docker run --name some-mysql -e "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("MYSQL_ROOT_PASSWORD")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("my-secret-pw -d mysql:tag\n")])])]),s("h3",{attrs:{id:"命令式配置文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命令式配置文件"}},[a._v("#")]),a._v(" 命令式配置文件")]),a._v(" "),s("p",[a._v("docker-compose 使用的就是命令式配置文件的方式，往往我们需要将容器的信息以及容器的依赖关系编写进一个 yaml 格式的配置文件，然后通过 docker-compose 的 up 命令将配置文件交给 docker-compose。")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("docker-compose -f standalone-mysql-5.7.yaml up\n")])])]),s("p",[a._v("同样的方式还有 kubectl 的 replace 命令。这种操作方式的特点是每一次运行都会创建出一个全新的 API 对象出来。")]),a._v(" "),s("h3",{attrs:{id:"声明式-api-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#声明式-api-2"}},[a._v("#")]),a._v(" 声明式 API")]),a._v(" "),s("p",[a._v("在 kubernetes 中通常我们使用 kubectl apply 命令就是使用了声明式 API 的方式在管理容器。")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("kubectl apply -f mysql-statefulset.yaml\n")])])]),s("p",[a._v("声明式 API 可以有多个 API 写入端通过 patch 的方式修改同一个 API 对象，多个 API 写入端修改同一个 API 对象往往会伴随着 merge 操作(声明中有相同的字段内容)。")]),a._v(" "),s("p",[a._v("在 kubernetes 中用户往往只需要声明对象的基本信息以及预期状态，通过 apply 提交给 kubernetes 后，kubernetes 会有与之相关的一个或多个Initailizer、控制器等。通过 patch 的方式来修改同一份 API 对象。以此来联合达到用户所声明的预期状态。而用户在之后的时间里有修改 API 对象的需求也是通过 apply 即 patch 的方式来修改 API 对象这使得控制器原先对 API 对象的修改得以保留，用户新的修改不会产生新的 API 对象。")]),a._v(" "),s("p",[a._v("这种持续修改并且作用在同一个 API 对象上的特性正是声明式 API 对象的好处。")]),a._v(" "),s("blockquote",[s("p",[a._v("kubernetes 能达到声明式 API 效果的命令还有 kubectl set image 以及 kubectl edit 等。")])]),a._v(" "),s("h2",{attrs:{id:"api-对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#api-对象"}},[a._v("#")]),a._v(" API 对象")]),a._v(" "),s("p",[a._v("kubernetes 中提供了许许多多的 API 资源对象，这些 API 资源对象有的用来描述应用，有的用来描述资源，而有的则用来描述编排方式。")]),a._v(" "),s("p",[a._v("常见的 API 对象有：")]),a._v(" "),s("ul",[s("li",[a._v("Pod")]),a._v(" "),s("li",[a._v("ConfigMap")]),a._v(" "),s("li",[a._v("Deployment")]),a._v(" "),s("li",[a._v("StatefulSet")]),a._v(" "),s("li",[a._v("Service")]),a._v(" "),s("li",[a._v("CronJob")])]),a._v(" "),s("p",[a._v("kubernetes 中 API 对象可以通过一定的规则来定位。主要通过 Group、Version、Resouce 三部分来定位。")]),a._v(" "),s("p",[a._v("比如声明一个 CronJob 对象：")]),a._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" batch/v2alpha1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" CronJob\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("...")]),a._v("\n")])])]),s("p",[a._v("其中 batch 就是 Group，v2alpha1 就是 Version，而 CronJob 就是 Resouce，kubernetes 中就是通过 version 来进行 API 对象的多版本管理的。")]),a._v(" "),s("p",[a._v("但需要注意的是像 Pod、Deployment 等 kubernetes 中标准的 API 对象它们的 Group 为 “ ”，所以这些对象的定义往往是这样的：")]),a._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" Pod\n")])])]),s("p",[a._v("它们会从 Version 开始匹配。")]),a._v(" "),s("p",[a._v("从 v1.7 之后 kubernetes 允许我们通过 CRD(Custom Resource Definition)来定义我们自己的 API 资源对象。")]),a._v(" "),s("p",[a._v("比如我们定义一种 Network API 资源；")]),a._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" apiextensions.k8s.io/v1beta1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" CustomResourceDefinition\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" networks.samplecrd.k8s.io\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("group")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" samplecrd.k8s.io\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("version")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" v1\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("names")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" Network\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("plural")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" networks\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("scope")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" Namespaced\n")])])]),s("p",[a._v("将这个 CRD 通过 kubectl apply 交给 kubernetes 之后，我门就能创建自己的 CR 了。")]),a._v(" "),s("p",[a._v("比如：")]),a._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("apiVersion")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" samplecrd.k8s.io/v1\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("kind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" Network\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("metadata")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" example"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("-")]),a._v("network\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("spec")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("cidr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"192.168.0.0/16"')]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("gateway")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"192.168.0.1"')]),a._v("\n")])])]),s("p",[a._v("其中 samplecrd.k8s.io 就是我们自定义资源的组，v1 是我们的版本，而 Network 就是我们的资源名称。")]),a._v(" "),s("blockquote",[s("p",[a._v("需要注意的是资源组的名称必须有两个 "),s("code",[a._v(".")]),a._v("，比如 samplecrd.k8s.io 。")])]),a._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),s("p",[a._v("声明式 API是 kubernetes 编排赖以生存的特性，深刻理解它有助于我们编写 operator。kubernetes 提供了许许多多的 API 对象资源来满足日常的编排需求。而面对相对复杂的编排需求，可以使用 CRD 来定义 API 对象资源，但光有 API 对象资源是不够的，我们还需要编写对应的控制器。而 CRD 加上自定义控制器就可以编写出自定义 operator 了。")]),a._v(" "),s("comment")],1)}),[],!1,null,null,null);t.default=n.exports}}]);